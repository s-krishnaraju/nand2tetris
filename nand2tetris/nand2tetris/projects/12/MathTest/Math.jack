// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Math.jack
/**
 *  A library of commonly used mathematical functions.
 *  All functions runs in O(n), where n is the number of num used
 *  for representing a two's complement integer value (16 in the Hack computer). 
 *  Note: Jack compilers implement multiplication and division
 *  using calls to OS functions in this class.
 */

class Math {
    static int n;             // Number of num used for representing a two's complement integer
    static Array powersOfTwo; // Stores 2^0, 2^1, 2^2,..., 2^(n-1)

    // Initializes the Math library.
    function void init() {
        var int i, pwr;
        let n  = 16;
        let powersOfTwo = Array.new(n);
        let i = 0; 
        let pwr = 1;
        while(i<n){
           let powersOfTwo[i] = pwr;
           let pwr = pwr + pwr;  
           let i = i+1;
        }
        return;
    }

    function int getBit(int num, int i) {
        var int power, x;

        if (i > 15){
            return -1;
        }
        let power = powersOfTwo[i];

        if (power > num){
            return -1;
        }

        let x = power & num; 

        if (x = 0){
            return 0;    
        } else {
            return 1;
        }
    }

    /** Returns the product of x and y. 
     *  When a Jack compiler detects the multiplication operator '*'
     *  in an expression, it handles it by invoking this method. 
     *  Thus, in Jack, x * y and Math.multiply(x,y) return the same value. */
    function int multiply(int x, int y) {
        var boolean neg;
        var int sum, i, bit, shiftedx;
        let i = 0;
        
        if(((x < 0) & (y < 0)) | ((x > 0) & (y > 0)) ){
            let neg = false;
        }else{
            let neg = true;
        }

        let x = Math.abs(x);
        let y = Math.abs(y);
        
        let shiftedx = x;
        let sum = 0;
        while(true){
            let bit = Math.getBit(y, i);
            if (bit = -1){
                if (neg){
                    return -sum;
                } else {
                    return sum;
                }
            } 
            if (bit = 1){
                let sum = sum + shiftedx;
            }
            // x*2
            let shiftedx = shiftedx + shiftedx;
            let i = i + 1;
        }
    }

    /** Returns the integer part of x / y.
     *  When a Jack compiler detects the division operator '/'
     *  an an expression, it handles it by invoking this method.
     *  Thus, x/y and Math.divide(x,y) return the same value. */
     // 30
     // 1000
     // 3   30-8*3 = 6  6-2*3   = 0
     // start at num greatest bin place where y*bin <= x 
     // 32766/ (-32767) failing 
     // Overflowing on 20761/10
    function int divide(int x, int y) {
        var boolean loop, neg;
        var int res, last, i, a, diff;
        var Array arr;

        if(((x < 0) & (y < 0)) | ((x > 0) & (y > 0)) ){
            let neg = false;
        }else{
            let neg = true;
        }

        let x = Math.abs(x);
        let y = Math.abs(y);

        let arr = Array.new(15);
        let loop = true;
        let i = 0;
        let arr[i] = y; 

        // failing on 20761/10 
        while(loop){
            let a = arr[i];
            if((x-a) < y){
                let loop = false;
            } else{
               // this is like multiplying y by 2^i at each loop
               // this is so we get the largest "i" y*2^i <= x
                let i = i+1;
                let arr[i] = a+a;
            }
        }

        // now a is largest a w/ a <= x
        let loop = true;
        let last = x;
        let res = 0;
        while(loop){
            let diff = last - arr[i];
            if (diff < 0){
                let i = i-1;
            } else {
                let res = res + powersOfTwo[i]; // what we multiplied y by 
                let last = diff; 
            }
            if(i<0){
                let loop = false;
            }
        }

        if(neg & (~(res=0))){
            return -res;
        }else{
            return res;
        }
    }

    /** Returns the integer part of the square root of x. */
    // y = sqrt(x) then we know that in 0 ... 9  there must be a num n such that n^2 = x and sqrt(x) = n
    // we can use binary search to find that num

    function int sqrt(int x) {
        var int l, r, m, sqr;
        let l = 0;
        let r = x;
        
        while(l<r){
            do Output.printString("L: ");
            do Output.printInt(l);
            do Output.println();
            do Output.printString("R: ");
            do Output.printInt(r);
            do Output.println();
            // round down
            // round down
            let m = (l+r)/2;
            do Output.printString("M: ");
            do Output.printInt(m);
            do Output.println();
            let sqr = m*m;
            if(sqr = x){
                return m;
            }        
            if(sqr < x){
               let l = m+1; 
            }else{
                let r = m;
            }
        }

        let sqr = l*l;
        if(sqr > x){
            return l-1;
        }else {
            return l;
        }
    }

    /** Returns the greater value. */
    function int max(int a, int b) {
       if(a>b) {
           return a;
       }else {
           return b;
       }
    }

    /** Returns the smaller value. */
    function int min(int a, int b) {
        if(a<b){
            return a;
        }else{
            return b;
        }
    }

    function int toNeg(int x){
        let x = ~x;
        let x = x + 1;
        return x;
    }

    /** Returns the absolute value of x. */
    function int abs(int x) {
        var int r; 
        if (x < 0){
            let r = x - 1;
            let r = ~r;
            return r;
        } else {
            return x;
        }
    }
}
